Общий подход к использованию интерфейсных функций {#sect_gen_descr}
==============================================================

  Общий алгоритм для работы с модулем. {#sect_gen_alg}
  ==============================================================

Данный раздел описывает типичную последовательность вызова функций для работы с модулем L502. Более подробно каждый шаг будет описан в последующих разделах.

Типичная последовательность вызовов имеет следующий вид:
 1. Получение списка серийных номеров модулей L502, присутствующих в системе, с помощью функции L502_GetSerialList().
 2. Если в системе присутствует нужный модуль L502, создаем описатель модуля с помощью L502_Create().
 3. Установить соединение с модулем, передав созданный описатель и серийный номер выбранного устройства в функцию L502_Open().
 4. При необходимости, получить дополнительную информацию о устройстве с помощью L502_GetDevInfo() (в частности для проверки наличия сигнально процессора BlackFin).
 5. При наличии сигнального процессора (и желании работать с его использованием) загрузить прошивку сигнального процессора с помощью L502_BfLoadFirmware().
 6. Установка параметров модуля с помощью [набора функций для изменения настроек модуля](@ref func_config) (названия функций начинаются с L502_Set)
 7. Передача установленных параметров в модуль с помощью L502_Configure().
 8. Работа с модулем в синхронном и/или асинхронном режиме (описана в последующих подразделах).
 9. Закрытие модуля L502_Close().
 10. Освобождение описателя модуля функцией L502_Free().   
 
 
 Работа с модулем при синхронном вводе {#sect_gen_sync_in}
 ----------------------------------------------------------
 
 Типичная работа с модулем при синхронном вводе состоит из следующих шагов:
 1. Разрешение нужных синхронных потоков (АЦП и/или цифровых данных) с помощью L502_StreamsEnable().
 2. Запуск синхронных потоков L502_StreamsStart().
 3. Чтение принятых данных из модуля с помощью L502_Recv().
 4. Обработка прочитанных данных с помощью L502_ProcessData().
 5. При необходимости приема и обработки следующего блока, переход к пункту 3.
 6. Останов синхронных потоков с помощью L502_StreamsStop().
 
 
 Работа с модулем при синхронном потоковом выводе {#sect_gen_sync_out}
 --------------------------------------------------------------
 
 Типичная работа с модулем при синхронном выводе состоит из следующих шагов:
 1. Разрешение нужных синхронных потоков (каналы ЦАП, цифровые выходы) с помощью L502_StreamsEnable().
 2. Запуск предварительной загрузки данных на вывод с помощью L502_PreloadStart().
 3. Подготовка блока данных на запись с помощью L502_PrepareData().
 4. Запись подготовленного блока в модуль с помощью L502_Send().
 5. При необходимости повторить пункты 3. и 4. нужное количество раз. При этом общий размер предварительно загруженных данных не должен превысить размер буфера (по-умолчанию 9 МСлов)
 6. Запуск синхронных потоков вызовом L502_StreamsStart().
 7. Каждый раз при необходимости подгрузить новые данные в буфер выполнить пункты 3. и 4. 
 8. По завершению работы выполнить останов синхронных потоков с помощью L502_StreamsStop().
 
 Работа с модулем при циклическом выводе {#sect_gen_cycle_out}
 -----------------------------------------------------------------
 Для выставления циклического сигнала без подкачки типичная последовательность выглядит так:
 1. Разрешение нужных синхронных потоков (каналы ЦАП, цифровые выходы) с помощью L502_StreamsEnable().
 2. Выделение циклического буфера указанного размера с помощью L502_OutCycleLoadStart().
 3. Загрузка данных указанного размера для циклического вывода с помощью одного или нескольких вызовов L502_Send().
 4. Сделать загруженный сигнал активным с помощью L502_OutCycleSetup().
 5. Запустить синхронный ввод-вывод через L502_StreamsStart().
 6. При необходимости вывести новый сигнал выполнить шаги 2.-4.
 7. По завершению работы остановить синхронный ввод-вывод с помощью L502_StreamsStop() или только циклический вывод через L502_OutCycleStop().
   
 
 Работа с модулем при асинхронном вводе-выводе {#sect_gen_async}
 -----------------------------------------------------------------
 
 Типичная работа при асинхронном вводе-выводе состоит из вызова одной из функций:
 - L502_AsyncInDig() - асинхронный ввод значений цифровых линий
 - L502_AsyncOutDig() - асинхронный вывод значений на цифровые линии
 - L502_AsyncOutDac() - асинхронный вывод значения на один из каналов ЦАП
 - L502_AsyncGetAdcFrame() - асинхронный прием одного кадра АЦП
 
 
 
 
  Создание и освобождение описателя модуля. {#sect_descr}
  ==============================================================
   
  Вся работа с модулем L502 осуществляется через описатель модуля типа #t_l502_hnd. Описатель модуля представляет собой непрозрачный указатель на структуру, которая хранит всю информацию о модуле и состоянии соединения с ним. Пользователь не имеет прямого доступа к полям структуры и все действия с модулем выполняются посредством вызова соответствующих функций библиотеки, которые принимают описатель модуля в качестве первого параметра.

  Перед попыткой установить связь с модулем необходимо создать описатель, вызвав функцию L502_Create(), которая выделяет память под структуру, инициализирует ее поля значениями по-умолчанию и возвращает указатель на нее - описатель модуля.

  После того как работа с модулем завершена, выделенная функцией L502_Create() память должна быть освобождена посредством вызова L502_Free(). После освобождения описатель уже не может использоваться.
  
  Открытие связи с модулем. {#sect_open}
  ==============================================================
  
  Для начала работы с модулем необходимо установить с ним связь с помощью функции L502_Open(). Для различия модулей используется их серийные номера.

  Получить список серийных номеров всех найденных модулей L502 можно с помощью функции L502_GetSerialList(). Данная функция принимает плоский массив, в который будут сохранены найденные серийные номера, и максимальное количество серийных номеров, которое можно сохранить в переданный массив. 
  
  В простейшем случае можно задать максимальное значение модулей и для серийных номеров использовать статически выделенный массив: 
  
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
  #define MAX_MODULES_CNT  16
  
  char serial_list[MAX_MODULES_CNT][L502_SERIAL_SIZE];
  int32_t get_list_res = L502_GetSerialList(serial_list, MAX_MODULES_CNT, 0, NULL);
  if (get_list_res<0)
  {
      /* Ошибка получения списка серийных номеров */
  }
  else if (get_list_res==0)
  {
  	   /* Не найдено ни одного модуля */
  }
  else
  {
  	   /* Найдено get_list_res модулей */  	   
  }  
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  В общем случае для работы с произвольным максимальным количеством модулей можно воспользоваться третьим параметром функции для получения количества найденных модулей в системе. При этом в качестве массива серийных номеров можно передать нулевой указатель и указать нулевой размер массива. После этого можно динамически выделить массив под полученное количество серийных номеров и повторно вызвать L502_GetSerialList() для получения серийных номеров всех модулей L502:
  
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
   uint32_t dev_cnt;
   int32_t res;
   
   /* Получаем количество модулей в системе */
   res  = L502_GetSerialList(NULL, 0, 0, &dev_cnt);
   if (res<0)
   {
   		/* Ошибка получения списка серийных номеров */
   }
   else if (dev_cnt==0)
   {
   		/* Не найдено ни одного модуля */
   } 
   else
   {
       /* Выделяем плоский массив под dev_cnt серийных номеров размером 
       	  dev_cnt*L502_SERIAL_SIZE */
       t_l502_serial_list serial_list=
       	   (t_l502_serial_list)
       		malloc(dev_cnt*L502_SERIAL_SIZE);
       if (serial_list==NULL)
       {
       		/* Ошибка выделения памяти */
       }
       else
       {
       		res = L502_GetSerialList(serial_list, dev_cnt, 0,
       		                         NULL);
       		if (res>0)
       		{
           		/* Получено res серийных номеров */
          	}
          	/* Освобождаем выделенный массив под серийные номера */
          	free(serial_list);
       }
   }   
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Следует отметить, что с одним модулем одновременно может быть установлено только одно соединение. При попытке открыть модуль, с которым уже установлено соединение через другой описатель (возможно, в другой программе) L502_Open() вернет #L502_ERR_DEVICE_ACCESS_DENIED. При этом L502_GetSerialList() по-умолчанию возвращает список всех серийных номеров модуля, включая те, с которыми уже установлено соединение. Если нужно получить список только тех устройств, с которыми еще не установлено соединения, то в L502_GetSerialList() можно передать флаг #L502_GETDEVS_FLAGS_ONLY_NOT_OPENED.

  Если в качестве серийного номера в L502_Open() передать нулевой указатель или пустую строку, то будет предпринята попытка открыть первый модуль, с которым удастся успешно установить соединение. Если ни с одним модулем установить соединение не удалось, то будет возвращена ошибка, полученная при попытки открыть последний модуль. То есть, при наличии двух модулей L502 в системе, первый вызов L502_Open() установит соединение с первым модулем L502, второй вызов - со вторым, а третий вернет уже ошибку доступа  #L502_ERR_DEVICE_ACCESS_DENIED.

  Режимы работы с сигнальным процессором и без него {#sect_modes}
  ==============================================================
  
  Модуль L502 может работать в двух режимах:
  - В штатном режиме (#L502_MODE_FPGA) вся обработка данных выполняется аппаратно в ПЛИС модуля, а управление модулем осуществляется путем прямой записи значений в регистры ПЛИС. В этом режиме доступны все штатные функции сбора данных, однако у пользователя нет возможности расширить функциональные возможности самого модуля. Этот режим доступен для всех модификаций L502.
  - В режим работы с сигнальным процессором (#L502_MODE_DSP) все управление сбором данных выполняется сигнальным процессором BlackFin и все потоки данных на ввод и вывод идут через него. Таким образом, пользователь может путем создания модифицированной прошивки BlackFin реализовать дополнительные возможности (например, обратную связь в режиме реального времени). Этот режим доступен только для модификаций L-502-P-G м L-502-P-G-D.
  
  При включении питания, модуль всегда находится в штатном режиме работы без использования сигнального процессора. Для работы сигнального процессора необходимо предварительно загрузить в него программу (прошивку). Это можно сделать из файла формата ldr с помощью функции L502_BfLoadFirmware(). После этого, будет автоматически переведена в режим с сигнальным процессором.
    
  При необходимости, можно специально переключить режим работы с помощью L502_SetMode(). Это может потребоваться, например, если прошивка загружена в BlackFin по интерфейсу JTAG. Кроме того, следует иметь ввиду, что при открытии связи с устройством, не производится изменение режима работы модуля. Т.е. если одна программа установила режим #L502_MODE_DSP, то при последующем открытии модуля из другой программы этот режим сохранится. В этой связи может понадобиться явно перевести модуль в штатный режим с помощью L502_SetMode().
  
  Все настройки модуля и работа с синхронным вводом-выводом должны выполняться после установки нужного режима.
  
  В любой момент можно узнать текущий режим работы с помощью L502_GetMode().
  
  Программно проверить наличие сигнального процессора можно, получив информацию о модуле с помощью L502_GetDevInfo() и проверив, установлен ли флаг #L502_DEVFLAGS_BF_PRESENT.
  
  
  Установка настроек модуля {#sect_config}
  ==============================================================
  
  Перед использованием модуля, как правило, необходимо выполнить настройку его параметров. Сперва все настройки записываются в поля структуры описателя модуля с помощью функций, начинающихся с L502_Set, которые будут описаны в последующих подразделах, после чего установленные параметры передаются в модуль с помощью L502_Configure().
  
    Настройка последовательности опроса каналов АЦП {#sect_config_adc_table}
    -------------------------------------------------------------------------
  
  L502 является модулем с последовательной коммутацией каналов. То есть измерение нескольких каналов происходит последовательно, путем переключения входного коммутатора АЦП. Как и в большинстве моделей "Л Кард" последовательность опроса каналов задается с помощью управляющей таблицы логических каналов АЦП. Всего таблица может содержать от одного до #L502_LTABLE_MAX_CH_CNT логических каналов.
  
  Каждый логический канал задается следующие параметры:
  - номер физического канала, с которого производится измерение. Номер физического канала задается, считая от 0, то есть 0 означает первый канал, 1 – второй и т.д. Таким образом, в дифференциальном режиме номер канала может быть от 0 до 15, а в режиме измерения с общей землей – от 0 до 31.
  - режим измерения АЦП из #t_l502_lch_mode.
  - используемый диапазон измерения (из #t_l502_adc_range).
  - коэффициент усреднения по заданному логическому каналу  (см. раздел @ref sect_config_lch_avg).
  
  Задать параметры логического канала с нужным номером можно с помощью функции L502_SetLChannel(), а количество логических каналов в управляющей таблице - с помощью L502_SetLChannelCount().
  
  Например, необходимо измерить сперва напряжение входа X1 относительно общей земли для диапазона +/-10В, затем измерить значение на 16 канале в дифференциальном режиме (между входами X16 и Y16) с диапазоном +/-1В, а затем  измерить напряжение между Y1 и общей землей (17 канал в режиме с общей землей) с диапазоном +/-0.2В (Назначение выводов сигнального разъема и подключение сигналов к модулю описано в [\"Руководстве пользователя\"](http://www.lcard.ru/download/l-502_users_guide.pdf)). В этом случае настройка логической таблицы будет выглядеть следующим образом:
  
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
	/* устанавливаем 3 логических канала */
	int32_t err = L502_SetLChannelCount(hnd, 3);
	if (!err)
	{
	 	/* первый логический канал соответствует измерению 1 канала
	 	   относительно общей земли */
	 	err = L502_SetLChannel(hnd,0,0,L502_LCH_MODE_COMM,L502_ADC_RANGE_10,0);
	}
	if (!err)
	{
	 	 /* второй логический канал соответствует измерению 16 канала 
	 	 	в диф. режиме */
	 	 err = L502_SetLChannel(hnd,1,15,L502_LCH_MODE_DIFF, L502_ADC_RANGE_1, 0);
	}
	if (!err)
	{
		/* третий логический канал - измерение 17-го канала 
		   относительно общей земли */
		err = L502_SetLChannel(hnd,2,16,L502_LCH_MODE_COMM, L502_ADC_RANGE_02, 0);
	}
  
  	if (!err)
  	{
  		/* установка других настроек */
  		
  	}  
 	if (!err)
  	{
  		/* передаем настройки в модуль */
  		err = L502_Configure(hnd,0);
  	}  
  	if (err)
  	{
  		/* произошла ошибка при настройке параметров... */
  	}
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  
  После завершения измерения с настройками, соответствующими последнему логическому каналу, следует измерение соответствующее снова первому (с нулевым номером) логическому каналу. Последовательность измерений соответствующая одному проходу логической таблицы называется кадром.

При желании, между завершением измерения соответствующего последнему логическому каналу кадра и первому логическому каналу следующего кадра может быть вставлена межкадровая задержка.


  Настройка частоты синхронного ввода/вывода {#sect_config_freq}
  -------------------------------------------------------------------------

Все частоты потокового сбора и выдачи данных основываются на опорной частоте синхронизации. В качестве опорной частоты может использоваться внутренний источник частоты или внешний. В первом случае, опорная частота может быть 2МГц либо 1.5МГц. По умолчанию используется 2МГц. Изменить ее можно с помощью функции L502_SetRefFreq().

Частота сбора АЦП получается с помощью деления значения опорной частоты на установленный коэффициент, который может быть в диапазоне от 1 до #L502_ADC_FREQ_DIV_MAX. Кроме того, как уже упоминалось [в предыдущем разделе](@ref sect_config_adc_table), между измерением последнего логического канала одного кадра и началом следующего кадра, может быть добавлена межкадровая задержка. Межкадровая задержка задается в виде количества периодов опорной частоты синхронизации. 

Делитель частоты сбора АЦП и количество периодов опорной частоты для межкадровой задержки можно задать явно с помощью функций L502_SetAdcFreqDivider() и L502_SetAdcInterframeDelay() соответственно. Вместо этих функций для удобства можно использовать функцию L502_SetAdcFreq(), которой можно передать значения частоты сбора АЦП и частоты кадров в Герцах, а функция сама рассчитает нужный делитель и значение межкадровой задержки, чтобы полученные частоты были наиболее близки к указанным. При этом функция вернет реально установившиеся значения частот. 

Под частотой сбора АЦП (f_acq) понимается величина, обратная времени одного преобразования, соответствующего одному логическому каналу. Под частотой кадров (f_frame) понимается величина, обратная времени от начала измерения первого логического канала одного кадра до начала измерения первого логического канала следующего кадра. Это частота соответствует частоте сбора для одного логического канала.

Ниже приведена диаграмма, иллюстрирующая на примере сбора при заданных трех логических каналах, как определяются упомянутые выше частоты.

\image latex doc/images/adc_frame.jpeg "Диаграмма сбора АЦП для трех логических каналов" width=0.6\textwidth
\image html adc_frame.jpeg "Диаграмма сбора АЦП для трех логических каналов"

Если межкадровая задержка не нужна, то можно передать нулевой указатель в качестве второго параметра L502_SetAdcFreq(), тогда будет использоваться всегда нулевая межкадровая задержка (т.е. измерение следующего кадра начнется сразу после завершения предыдущего).

Помимо синхронного ввода с АЦП модуль L502 позволяет осуществлять синхронный ввод с 18 цифровых входов. Так же как и для синхронного сбора данных АЦП, частота синхронного цифрового ввода определяется как опорная частота, разделенная на коэффициент, который можно установить с помощью L502_SetDinFreqDivider(). Так же можно вызывать функцию L502_SetDinFreq(), чтобы она рассчитала этот коэффициент для получения наиболее близкой частоты к указанной. Для синхронного ввода цифровых линий нет ни логической таблицы (так как каждый раз вводятся все 18 линий), ни межкадровой задержки - при запуске синхронного ввода все измерения выполняются через одинаковые промежутки времени.

Плата L502 так же позволяет осуществить синхронный вывод на два канала ЦАП и цифровые выводы. При этом вывод каждого канала осуществляется с частотой в два раза меньшей значения опорной частоты. Соответственно, частоты вывода специально настраивать не нужно.

  
  Коэффициент усреднения для логического канала {#sect_config_lch_avg}
  -------------------------------------------------------------------------
  
Реально микросхема АЦП всегда работает на частоте равной опорной частоте синхронизации. В случае, если частота сбора АЦП установлена меньше, чем опорная частота синхронизации, то на одно измерение значения логического канала приходится n измерений АЦП (n = f_acq/f_ref - отношение установленной частоты сбора АЦП к опорной частоте дискретизации).

При отключенном усреднении, первые n-1 измерений отбрасывается, что увеличивает время установления сигнала. При необходимости можно использовать несколько последних отсчетов (navg) для получения результирующего значения. Тогда результирующего значение будет являться средним между navg последними измерениями, однако это сокращает соответственно время на установления сигнала. Естественно navg всегда меньше либо равно n. Кроме того navg не может превышать максимального значения, равного #L502_LCH_AVG_SIZE_MAX.

Значение navg задается последним параметром функции L502_SetLChannel(). Значение равное 1 означает отсутствие усреднения. Значения равное 0, означает что коэффициент усреднения может быть выбран по-усмотрению библиотеки. В текущей реализации значение 0 аналогично значению 1, но это может быть изменено в последующих версиях.


  Настройка режимов синхронизации {#sect_config_sync_mode}
  -------------------------------------------------------------------------
  
  По умолчанию в качестве опорной частоты синхронизации используется внутренняя частота модуля, а запуск всех синхронных измерений осуществляется при выполнении функции L502_StreamsStart().
  
  Однако, при необходимости, возможно задать как внешний источник опорной частоты, так и внешний сигнал запуска синхронного сбора/выдачи данных.
  
  Для этого могут быть использованы входы цифрового разъема DI_SYN1 и DI_SYN2 (может использоваться как фронт, так и спад одного из этих сигналов), либо также может использоваться разъем синхронизации для организации синхронного сбора данных по принципу ведущий-ведомые.
  
  Выбор внешнего сигнала для задания опорной частоты синхронизации задается с помощью L502_SetSyncMode(), а условие запуска с помощью функции L502_SetSyncStartMode(). Следует отметить, что если задано внешнее событие запуска, то для того, чтобы модуль перешел в режим ожидания этого события, необходимо вызвать L502_StreamsStart().
  
  Останов синхронного сбора/выдачи данных всегда осуществляется программно с помощью L502_StreamsStop().
  
  При использовании разъема синхронизации для организации сбора данных по принципу ведущий-ведомые, для ведущего модуля источником опорной частоты синхронизации остается внутренняя частота (режим #L502_SYNC_INTERNAL), а каждый ведомый модуль использует опорную частоту и/или признак запуска сбора от внешнего мастера, т.е. для каждого ведомого модуля должен быть установлен режим #L502_SYNC_EXTERNAL_MASTER.

  
  
  Синхронный и асинхронный режимы работы. {#sect_sync_async}
  ===========================================================================
  
  Для модуля L502 доступны следующие данные на ввод:
  - отсчеты с АЦП 
  - значения цифровых входов 
  
  Также модуль может быть использована для вывода:
  - отсчетов на первый канал ЦАП
  - отсчетов на второй канал ЦАП
  - значений на цифровые выходы
  
  Таким образом, имеется 2 канала на ввод и 3 канала на вывод.
  
  Каждый из этих каналов может работать как в синхронном режиме, так и асинхронно. При этом каждый канал может быть настроен индивидуально, то есть можно выполнять, например, асинхронный ввод цифровых линий на фоне синхронного потокового сбора с АЦП или выводить на один канал ЦАП сигнал в синхронном потоковом режиме, в то время как в другой выставлять значения асинхронно. Единственное исключение - невозможно осуществить асинхронный ввод с АЦП на фоне синхронного сбора данных с цифровых входов.  
  
  
  Асинхронный режим работы {#sect_async_mode}
  -------------------------------------------------------------------------
  
  При включении питания все каналы находятся в асинхронном режиме.
  В асинхронном режимы при вызове функции асинхронного ввода/вывода производится однократный ввод или вывод указанной информации. При этом задержка от вызова функции до непосредственно момента измерения данных для ввода или выставления указанного значения на выходе для вывода точно не определена. Также точно не может быть определена задержка между двумя последовательными операциями ввода/вывода. 
  
  Плюсом асинхронного режима является простота его использования - достаточно одного вызова требуемой функции:
  - L502_AsyncInDig() - асинхронный ввод значений цифровых линий
  - L502_AsyncOutDig() - асинхронный вывод значений на цифровые линии
  - L502_AsyncOutDac() - асинхронный вывод значения на один из каналов ЦАП
  
  Для однократного ввода данных с АЦП используется функция L502_AsyncGetAdcFrame(), которая выполняет ввод одного кадра данных АЦП. В отличии от других функций асинхронного ввода-вывода, перед ее вызовом данной функции необходимо выполнить настройку модуля: необходимо задать управляющую таблицу АЦП (см. @ref sect_config_adc_table). Измерение логических каналов внутри кадра происходит синхронно с заданной частотой сбора АЦП. Асинхронным является ввод самих кадров, то есть задержка между измерением кадров при последовательном вызове L502_AsyncGetAdcFrame() не определена.
  
  Например, код для выполнения однократного измерения с 7-го физического канала в дифференциальным режиме с диапазоном +/-0.5В может выглядеть следующим образом:
  
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
	/* устанавливаем 1 логический канал в управляющей таблице */
	int32_t err = L502_SetLChannelCount(hnd, 1);
	if (!err)
	{
	 	/* логический канал соответствует измерению 7 канала 
	 		в диф. режиме */
	 	err = L502_SetLChannel(hnd,0,6,L502_LCH_MODE_DIFF,L502_ADC_RANGE_05,0);
	}
 	if (!err)
  	{
  		/* передаем настройки в модуль */
  		err = L502_Configure(hnd,0);
  	}  
  	if (!err)
  	{
  		/* Считываем кадр данных АЦП из одного отсчета */
  		double val;
  		err = L502_AsyncGetAdcFrame(hnd, 
  			    L502_PROC_FLAGS_VOLT, 1000, &val);
  		if (!err)
  		{
  			/* верно считали значение val */
  		}  		
  	}
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  Синхронный режим работы {#sect_sync_mode}
  -------------------------------------------------------------------------
  
  
  В синхронном режиме ввод или вывод данных осуществляется с заданной частотой, то есть время между соседними измерениями или выводом соседний отсчетов определено. Частоты сбора для каждого канала задаются относительно общей опорной частоты синхронизации (подробнее см. главу [\"Настройка частоты синхронного ввода/вывода\"](@ref sect_config_freq)) и запуск синхронного ввода-вывода для всех каналов осуществляется одновременно.
  
  Для запуска синхронного режима, необходимо сперва с помощью функции L502_StreamsEnable() разрешить синхронный режим по требуемым каналам, а затем запустить синхронный ввод/вывод по всем разрешенным каналам с помощью L502_StreamsStart().
  
  При синхронном вводе модуль производит измерения с заданной частотой и сам передает данные по интерфейсу PCI Express в буфер драйвера (с использованием BusMaster DMA). Принятые в буфер данные могут быть прочитаны программой с помощью L502_Recv(). 
  
  
  Аналогично, для синхронного вывода, модуль сам по мере необходимости считывает данные из буфера драйвера и выводит считанные отсчеты с заданной частотой. Данные в буфер драйвера должны быть предварительно записаны с помощью L502_Send(). При этом, если к моменту вывода очередного данные в буфер драйвера не поступили, то будет выведено предыдущее значение.
  
  В драйвере выделяется всего два буфера --- один на прием и один на передачу. То есть значения для синхронного ввода с цифровых линий и отсчеты АЦП передаются одним потоком, также одним потоком передаются все данные на вывод. Каждый отсчет передается в виде 32-битного слова, содержащего дополнительную информацию, включающую в себя признак, к какому типу данных относится данный отсчет.
  
  Разбор принятых данных на отсчеты АЦП и значения цифровых выводов осуществляется с помощью L502_ProcessData(). Помимо этого, данная функция также может осуществить перевод отсчетов АЦП в Вольты.
  Следует учесть, что в отличие от других изделий "Л Кард", применение калибровочных коэффициентов осуществляется аппаратно и значения уже приходят в виде 24-битных отсчетов с уже примененными коэффициентами.
  
  В 32-битном слове соответствующем отсчету АЦП передается дополнительно режим измерения и номер физического канала. L502_ProcessData() сравнивает эти значения теми которые были заданы при настройке управляющей таблицы, чтобы убедиться в корректности принимаемых данных. При этом L502_ProcessData() ожидает что с ее помощью будут обрабатываться все принятые данные.

  Данные от АЦП приходят в том порядке, в котором производятся измерения, т.е. сперва измерения соответствующие всем логическим каналам первого кадра, затем второго и т.д. В этом же порядке L502_ProcessData() возвращает и преобразованные отсчеты АЦП. При этом в L502_ProcessData() можно передавать и нецелое количество кадров (например, если запущен синхронный ввод с цифровых линий, то заранее сложно определить, сколько в принятом блоке данных содержится отсчетов с цифровых линий, а сколько отсчетов с АЦП), в этом случае L502_ProcessData() обработает и выдает все отсчеты, включая отсчеты нецелого кадра, а при следующем ее вызове проверяет, что отсчеты АЦП начинаются с логического канала, следующего за последним обработанным до этого каналом. Какой логический канал ожидается следующим для обработки можно узнать с помощью функции L502_GetNextExpectedLchNum().
  
  Например, пусть в управляющей таблице АЦП установлено 7 логических каналов. Если был принят блок данных от модуля содержащий 5 отсчетов АЦП (и произвольное количество значений цифровых входов, если включен синхронный ввод с цифровых линий) и обработан с помощью L502_ProcessData(), то L502_ProcessData() вернет преобразованные 5 отсчетов АЦП, соответствующие логическим каналом с индексами 0,1,2,3,4. Следующий логический канал, который ожидается для обработки - с индексом 5, поэтому L502_GetNextExpectedLchNum() вернет значение 5. Если обработать следующий блок данных, содержащий 5 следующих отсчетов, то L502_ProcessData() вернет отсчеты соответствующие каналам с индексами 5,6,0,1,2. Т.е. с помощью вызова L502_GetNextExpectedLchNum() можно узнать, какому логическому отсчету будет соответствовать первый элемент выходного массива при последующем вызове L502_ProcessData().
  
  Следует учесть, что по-умолчанию буфер в драйвере рассчитан на количество отсчетов, которое будет введено за 4с непрерывного сбора. Если вовремя не считывать данные с помощью L502_Recv(), то произойдет переполнение буфера в драйвере и часть данных, для которых не нашлось в буфере места будет потеряна. При последующем появлении места в буфере, в то место в потоке, где произошел разрыв непрерывного потока данных будет вставлено слово, представляющее собой сообщение о переполнении буфера. Если L502_ProcessData() во входном массиве обнаружит это слово, то функция вернет ошибку #L502_ERR_STREAM_OVERFLOW. При этом, как и в случае возникновения других ошибок обработки, все отсчеты, которые были до возникновения ошибки будут обработаны и возвращены в выходных массивах (размеры которых будут соответственно обновлены).
  
  Аналогично, для формирования общего потока на вывод в требуемом формате используется функция L502_PrepareData(), принимающая данные из трех массивов и сохраняющая их во внешний массив. Если какой-либо из источников не должен использоваться, то в качестве массива передается нулевой указатель. В частности, нулевой указатель должен быть передан для каналов, которые не были настроены на синхронный режим с помощью L502_StreamsEnable().
  
  Следует отметить, что если для синхронного ввода инициализация каналов DMA происходит по L502_StreamsStart(), так как данные начнут поступать только после запуска синхронного ввода, то с синхронным выводом дело обстоит несколько иначе. Так как по L502_StreamsStart() уже должна начаться выдача синхронных данных, то часть данных уже должна быть загружена в модуль. Таким образом, после разрешения синхронного вывода по нужным каналам с помощью L502_StreamsEnable() и до запуска синхронного вывода с помощью L502_StreamsStart() необходимо осуществить предзагрузку части данных синхронного потока. Для этого следует вызвать функцию L502_PreloadStart(), по которой в драйвере будет выделен буфер на передачу и инициализирован канал DMA на передачу, а затем записать часть синхронных данных в буфер драйвера с помощью L502_PrepareData() и L502_Send(). Если этого не сделать, то синхронный вывод начнется лишь после того как данные будут записаны в модуль и не будет привязан к началу синхронного сбора/выдачи данных.
  
  
  Циклический вывод {#sect_cycle_out}
  -------------------------------------------------------------------------
  Начиная с версии 1.0.4 драйвера и библиотеки введена поддержка циклического вывода на ЦАП и цифровые выводы. Этот режим позволяет загрузить сигнал полностью в буфер внутри драйвера, содержимое которого будет циклически передаваться в модуль L502 без необходимости дальнейшей подкачки.
  
  Данные для загрузки в циклический буфер подготавливаются также как и для потокового вывода с помощью L502_PrepareData() и записываются с помощью L502_Send() и могут содержать комбинацию данных на оба канала ЦАП и на цифровые выводы. Циклический вывод является вариантом синхронного вывода и для его работы нужно разрешить нужные потоки на вывод через L502_StreamsEnable() и должен быть запущен синхронный ввод-вывод через L502_StreamsStart(). Также как и с обычным потоковым выводом, часть каналов может использоваться для вывода циклического сигнала, а часть --- асинхронно. Однако нельзя часть каналов вывода использовать в циклическом режиме, а часть в потоковом режиме с подкачкой (естественно, циклический режим на вывод можно использовать с потоковым на ввод).
  
  Для вывода циклического сигнала в драйвере используется двойная буферизация - то есть может быть выделено два буфера, пока из одного сигнал циклически выводится, в другой может подгружаться следующий сигнал. Смена сигнала происходит по концу периода предыдущего. При этом после записи одного сигнала необходимо, чтобы успела пройти смена сигналов перед тем как можно будет загружать следующий.
  
  Для загрузки сигнала сперва вызывается функция L502_OutCycleLoadStart(), в которой задается размер циклического буфера, который будет использован для хранения отсчетов всех используемых каналов вывода. Например, если нужно использовать два канала ЦАП, на каждый из которых вывести сигнал из 1000 точек, то размер должен быть указан 2000. После этого отсчеты загружаются как и при потоковом выводе с подкачкой с помощью функций L502_PrepareData()/L502_Send(). При этом суммарно должно быть записано ровно столько же отсчетов, сколько было указано при вызове L502_OutCycleLoadStart(). После загрузки по вызову L502_OutCycleSetup() происходит переключение на загруженный буфер, при этом в зависимости от текущего состояния это приводит к следующему:
  - если синхронный ввод-вывод не запущен (не было вызова L502_StreamsStart()) то начинается предзагрузка циклического сигнала в плату, однако реально выдача сигнала начнется только при вызове L502_StreamsStart() (или по внешнему условию запуска). Это позволяет привязать начало вывода первого отсчета циклического сигнала к началу ввода.
  - если синхронный ввод-вывод запущен, но не было выведено ни одного циклического сигнала до этого, то по L502_OutCycleSetup() начинается вывод циклического сигнала.
  - если синхронный ввод-вывод запущен и уже выводится предыдущий циклический сигнал, то после вызова L502_OutCycleSetup() в драйвере будет взведен флаг о необходимости переключить сигналы. После этого события по достижению конца предыдущего циклического буфера будет произведена смена буферов вывода. Таким образом это позволяет производить смену сигнала всегда в известной точке. При смене сигнала происходит освобождение старого буфера и только после реальной смены можно будет вызвать следующий раз L502_OutCycleLoadStart() для загрузки следующего сигнала.
  
  Останов циклического вывода можно осуществить одним из следующий способов:
  - L502_OutCycleStop() останавливает циклический вывод после вывода последней точки на границе циклического буфера. То есть эта функция используется чтобы циклический вывод был завершен точно в известной точке и на выходах остались значения соответствующие последним отсчетам в циклическом сигнале.
  - L502_StreamsDisable() с указанием всех используемых каналов вывода приводит к немедленному завершению вывода и освобождением всех буферов. На выходах останутся значения которые были в момент вызова. После этого можно будет заново разрешить и проинициализировать вывод как в циклическом так и в потоковом режиме с подкачкой.
  - L502_StreamsStop() приводит к немедленному останову всех потоков и останову генерации опорной частоты синхронизации. На выходе остаются те значения которые были в момент вызова функции.
  
  
  
  Размер буфера и шаг прерываний для синхронного режима {#sect_sync_mode_buf}
  -------------------------------------------------------------------------
  
  В данном разделе приводится дополнительная информация о том, как можно настроить дополнительные параметры, управляющие передачей данных по DMA между платой и драйвером. Эти параметры по-умолчанию настраиваются библиотекой автоматически. Предполагается, что большинству пользователей должны подойти автоматически настраиваемые параметры и данный раздел не является обязательным. Однако для случаев, когда автоматически определенные параметры не подходят, пользователь может задать их самостоятельно. Для этого в этом разделе приводится описание как выбирается размер буфера и шаг прерывания библиотекой, что означают эти параметры и как их можно настроить вручную.  
  
  Как уже было сказано [в предыдущем разделе](@ref sect_sync_mode) прием и передача синхронных данных осуществляется через буфера в драйвере - один буфер на прием, один на передачу.
  
  Выделение буфера на ввод осуществляется по L502_StreamsStart(), если был разрешен хотя бы один источник для синхронного ввода. Выделение буфера на вывод осуществляется по L502_PreloadStart(). 
  
  При этом размер буфера определяется автоматически библиотекой в зависимости от установленной частоты передачи данных. Размер буфера рассчитывается так, чтобы его хватило на 4 секунды при синхронном вводе и на 3 секунды при синхронном выводе. 
  
  Передача данных между буфером драйвера и модулем осуществляется непосредственно самим модулем по DMA. При этом, чтобы драйвер мог узнать о том, что данные были записаны в буфер или прочитаны из него, при передаче определенного количества отсчетов модуль генерирует прерывание. То есть реально драйвер "узнает" о том, что были переданы данные только после того как будет передано заданное количество отсчетов, называемое в данной главе шагом прерываний (Точнее сказать, не позже, чем будет передано заданное количество отсчетов, так как драйвер может прочитать значение счетчика переданных данных из модуля и по другим условиям).
  
  Таким образом, малый шаг прерываний позволяет драйверу раньше узнает о принятых или переданных данных, но приводит к большей загрузке системы. Библиотека рассчитывает шаг прерываний так, чтобы прерывания происходили с частотой 64 раза в секунду.
  
  Если пользователя по каким-либо причинам не устраивают эти значения он может настроить их вручную с помощью функций L502_SetDmaBufSize() и L502_DmaSetIrqStep(). Эти функции должны быть вызваны до инициализации DMA-канала (до L502_StreamsStart() или L502_PreloadStart()).
  
  В частности, случаями когда значения библиотеки могут не устроить, могут быть следующие:
  - Пользователь использует свою прошивку BlackFin и использует каналы синхронных данных для передачи пользовательских данных, которые сильно изменяют скорость передачи данных. В этом случае библиотека не может правильно определить частоту передачи, так как не знает скорости передачи пользовательских данных.
  - Пользователь изменяет каналы, которые используются в синхронном режиме, на лету (после L502_StreamsStart()) и при этом скорости передачи по этим каналам существенно отличаются. Так как расчет размера буфера выполняется при инициализации канала, то он осуществляется только по тем каналам, которые были разрешены на тот момент. Если, например, был разрешен только синхронный сбор с АЦП на относительно небольшой частоте, то буфер будет выделен также небольшой. При этом, если после запуска сбора данных будет разрешен синхронный ввод с цифровых линий на частоте 2МГц, то вероятнее всего этот буфер окажется недостаточного размера, и с большой вероятностью произойдет его переполнение.
  Если же оба этих потока были разрешены изначально, а потом синхронный ввод цифровых линий будет запрещен, то рассчитанный изначально шаг прерывания будет слишком большим и данные от медленного потока АЦП будут обновляться с большими задержками. Если же частоты каналов соизмеримы, то включение/отключение одного из них не приведет к существенному изменению параметров.
  Изменение шага прерывания и размера буфера при запущенном сборе данных на текущий момент невозможно. 
  
\tableofcontents
