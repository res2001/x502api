Подключение библиотеки {#sect_setup}
==============================================================

Для написания собственного программного обеспечения, работающего с модулями L502, необходимо выполнить следующее:
1. Установить драйвер для модулей с интерфейсом PCI Express фирмы "Л Кард"
2. Установить динамическую библиотеку (l502api.dll для Windows или l502api.so для Linux) в директорию, присутствующую в соответствующей переменной окружения, либо в директорию с проектом. Динамическая библиотека необходима при написании программ на любом языке программирования, так как все привязки к языкам работают через библиотеку. 
3. Подключить библиотеку к проекту.

Для ОС Windows предоставляется установщик программного обеспечения для разработчика [\"L-Card PCI Express SDK\"](http://www.lcard.ru/download/lpcie_setup.exe), который позволяет установить драйвер для устройства, установить динамическую библиотеку в системную папку, а также установить все файлы, необходимые для подключения библиотеки к проекту и примеры в указанную папку. В дальнейшем в данной главе с помощью LPCIE_SDK_DIR будет обозначаться указанная папка при установке.

Подключение к проекту зависит от используемого языка и среды.

Подключение библиотеки при написании программы на языках C/C++. {#sect_setup_c}
=========================================================================

При написании на C/С++ при подключении необходимо выполнить следующее:
1. Включить в проект заголовочный файл "l502api.h", добавив при этом в проекте к путям для заголовочных файлов директорию LPCIE_SDK_DIR/inc.
2. Добавить в проект файл линкера для используемого компилятора:
    - <B> Microsoft Visual С++ </B>: LPCIE_SDK_DIR/lib/msvc
    - <B> Microsoft Visual С++ </B> 64-битный компилятор (подробнее о 64-битной версии [описано ниже](@ref sect_setup_64)): LPCIE_SDK_DIR/lib/msvc64
    - <B> Borland C++/Borland C++ Builder </B>: LPCIE_SDK_DIR/lib/borland
    - <B> MinGW </B>: LPCIE_SDK_DIR/lib/mingw
    - <B> MinGW </B> 64-битный компилятор: LPCIE_SDK_DIR/lib/mingw64

Использование библиотеки в проекте на Delphi {#sect_setup_delphi}
=========================================================================

Для написания программ на Delphi с использования API для работы с модулем L502, необходимо включить в проект программы два файла: LPCIE_SDK_DIR/pas/lpcieapi.pas и LPCIE_SDK_DIR/pas/l502api, которые представляют собой обертку над библиотекой l502api.dll. В файлах, использующих типы и функции из этого документа, необходимо подключить модуль l502api с помощью `uses l502api;`. При этом для 64-битного компилятора используются те же файлы, что и для 32-битного (см. @ref sect_setup_64).

Все функции, типы и константы библиотеки отображаются в Delphi один к одному, за исключением следующих моментов:
- все строки (серийные номера, строки с описанием кодов ошибок)преобразуются оберткой в тип `sting`, который используется стандартно для представления строк в Delphi (следует не забывать, что в последних версиях среды этот тип представляет собой юникодную строку). Исключением является структура #t_l502_info с информацией о модуле, в которой строки представлены массивом `AnsiChar` фиксированной длины.
- все функции работающие с массивами принимают в качестве параметра открытый массив (open array parameter), что означает, что в эти функции можно передать как статический массив, так и динамический (установив предварительно его длину с помощью `SetLength()`). При этом, так как массивы Delphi содержат в себе длину, то в функцию L502_GetSerialList() отдельно передавать размер массива не требуется. Однако в функциях для работы с данными (например, L502_Recv()) длина передается так же как и в функциях C, чтобы можно было использовать для приема не обязательно весь массив. При этом дополнительно проверяется, что переданная отдельным параметром длина не превышает реальную длину массива. В случае превышения будет возвращена ошибка #L502_ERR_INSUFFICIENT_ARRAY_SIZE.


Использование библиотеки в проекте на C# {#sect_setup_sharp}
=========================================================================

Для написания программ, работающих с платой L502, на языке C# (или на любом другом, поддерживаемым NetFramework), реализована специальная библиотека-обертка lpcieNet.dll. Она использует библиотеку C l502api, в которой реализована вся логика работы с устройством.
Установщик позволяет установить lpcieNet.dll в системный кэш (GAC), что позволяет не копировать библиотеку вместе с Вашим проектом. Однако, к сожалению, Visual Studio не позволяет добавлять в проект ссылки из системного кеша и Вам все равно придется саму ссылку делать на локальную копию (просто ее не обязательно будет распространять вместе с проектом). Библиотека в кеше имеет преимущество перед локальной и будет всегда использованна именно она, если установлена.

Для использования библиотеки достаточно добавить в проект ссылку на lpcieNet.dll и в исходниках подключить нужные пространства имен:

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cs}        
  using l502api;
  using lpcieapi;
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По сравнению с функциями языка C в обертке C# сделаны следующие изменения:
 - Так как С# --- объектно ориентированный язык, то для управления модулем L502 создан специальный класс L502.
 - Все функции, которые принимают описатель модуля первым параметром реализованы методами класса L502, при этом сам префикс L502_ не используется.
   Например, вместо `L502_Open(hnd, serial)`, используется `hnd.Open(serial)`.
 - Функции L502_Create() и L502_Free() вызывается в конструкторе и деструкторе класса L502, отдельными функциями не реализованы.
 - Функции, которые не требуют экземпляра модуля (не принимают описатель первым параметром), реализованы как статические функции класса L502.    Например не `L502_GetErrorString(err)`, а `L502.GetErrorString(err)`.
 - Функции типа Get/Set, которые принимают описатель модуля и один параметр, реализованы в виде свойств (properties) класса L502. Например, вместо `L502_SetLChannelCount(hnd, value)`, используется `hnd.LChannelCount = value`. Однако следует быть внимательным, так как неправильно устанавливаемое значение вызовет исключение `L502.Exception`.
 - Константы объявлены внутри класса L502 и без префикса L502_
 - Перечисления также объявлены как перечисления внутри класса L502 и без префикса `L502_ПЕРЕЧИСЛЕНИЕ`. Например не #L502_SYNC_INTERNAL, а `L502.Sync.INTERNAL`.
 - Коды ошибок, так как планируется использовать общие коды ошибок и для будущих модулей на шине PCI-Express, вынесены в перечисление ERR в классе lpcie.
 - Все функции, использующие в C строки в виде `char *`, используют в обертке строки типа `String`.
 - L502.GetSerialList() возвращает созданный внутри функции динамический массив строк (а не заполняет переданный), который уже содержит длину. Поэтому дополнительный параметр размера массива не требуется.
 - Так же как и в Delphi при работе с массивами данных передается длина дополнительным параметром, так как можно принимать меньше данных чем в выделенном массиве.
 - Функции, принимающие указатели в C, принимают параметры со спецификаторами out или ref, в зависимости от того, должна ли быть переменная проинциализирована перед вызовом функции или является выходным параметром.

 Пример программы на C# можно посмотреть в examples/cs [\"L-Card PCI Express SDK\"](http://www.lcard.ru/download/lpcie_setup.exe).
   

Использование библиотеки в проекте LabView {#sect_setup_labview}
=========================================================================

Вы можете управлять модулем L502 из LabView используя тот факт, что LabView поддерживает управляемые библиотеки NetFramework. Соответственно Вы имеете доступ ко всем функциям, которые реализует оболочка C# lpcieNet.dll (т.е. все доступные функции).
В отличие от Visual Studio LabView автоматически подхватывает .Net библиотеки из системного кэша (GAC) и Вы можете ссылаться на нее, а не хранить локальную копию вместе с программой.

Для работы с классами .Net в LabView есть специальная панель <B> Connectivity -> .Net </B>.

Вам необходимо использовать следующие блоки:
 - <B> Constructor Node </B> - создает объект. Должен быть создан для каждого модуля L502, с которым будете работать. При создании LabView предложит выбрать библиотеку и класс (нужно выбрать lpcieNet.dll и L502). Одним из выходов этого блока является ссылка на объект, которая используются как вход для остальных блоков для работы с модулем. Также с помощью конструктора создается объект логического канала со всеми настройками.
 - <B> Close Reference </B> - закрывает и удаляет объект. Должен вызываться для каждого созданного объекта L502 по завершению работы.
 - <B> Invoke Node </B> - вызов функции (метода класса). При работе с объектом на вход подается ссылка и входные параметры, а на выходе --- выходные параметры и обновленная ссылка (которая должна использоваться для блоков, которые будут вызваны после текущего). Входная ссылка и определяет, методы какого объекта используются (после заведения ссылки на вход имя класса появится в верхней строке, а при нажатии на вторую будет предложен на выбор его метод). Для функций, которые не работают с конкретным объектом (GetErrorString, GetSerialList --- эти функции статические и при выборе помечены [S] в начале) ссылку на вход подавать не обязательно. Однако они все равно принадлежат классу, который надо выбрать нажав правой кнопкой на блок и далее <B> Select Class/.Net </B>
 - <B> Property Node </B> - используется для установки или получения свойств. Через свойства устанавливается часть параметров (логическая таблица, режим синхронизации) и также можно получить информацию о модуле (в виде класса, каждое поле которого является также отдельным свойством). Можно устанавливать несколько свойств одним блоком, расширив его вниз. Также с помощью свойств можно задавать константы из перечислений (что может быть более понятно, чем просто подавать на вход числа) - в этом случае надо выбрать класс перечисление, а каждому значению соответствует свое свойство.
 
 Следует отметить особенность передачи массивов в качестве выходных параметров. Сами функции библиотеки для эффективности не выделяют массивов данных внутри себя, а используют переданные массивы для сохранения результатов. Поэтому такие параметры в LabView являются входными и выходными одновременно.  На вход необходимо подать массив размера, достаточного для сохранения результатов (при этом сами данные не имеют значения), а в качестве выходного параметра возвращается тот же массив, но уже заполненный результатами выполнения функции. Примером таких параметров могут служить параметр <B> buf </B> функции L502_Recv(), параметры <B> adc_data </B> и <B> din_data </B> функции L502_ProcessData(), а также параметр <B> out_buf </B> функции L502_PrepareData().
 
 
 Пример программы на LabView находится в examples/LabView [\"L-Card PCI Express SDK\"](http://www.lcard.ru/download/lpcie_setup.exe).



64-битная версия библиотеки {#sect_setup_64}
=========================================================================
На 64-биной версии Windows могут выполняться программы, как собранные 32-битным, так и 64-битным компилятором, поэтому большинство программ для Windows существует только в 32-битном варианте. 64-битный компилятор используют как правило для программ, работающих с большим количеством данных, так как это позволяет иметь процессу виртуальное пространство больше 4 Гбайт.

Для 64-битной Windows установщик [\"L-Card PCI Express SDK\"](http://www.lcard.ru/download/lpcie_setup.exe) ставит как 32-битную версию библиотеки, так и 64-битную. Первая ставится в директорию Windows/SysWOW64, где хранятся 32-битные библиотеки, а вторую в Windows/Sysnative, где соответственно лежат системные 64-битные библиотеки. При этом директория Windows/system32 указывает на одну из этих директорий в зависимости от разрядности самого приложения, которое обращается по указанному пути.

Таким образом, выбор библиотеки происходит автоматически, в зависимости от разрядности приложения. Единственным отличием при написании программ на C/C++ является необходимость подключить lib-файл в соответствии с разрядностью используемого компилятора.

Для программ на Delphi необходимо только указать для какой платформы будет собираться проект (win32 или win64) и собранная программа будет использовать библиотеку l502api.dll для которой программа была скомпилирована.

Программы на языке C# компилируются в машинный код при выполнении. При этом один раз созданная программа может выполняться как на 32-битной версии, так и на 64-битной версии виртуальной машины NetFramework (в проекте можно указать явно для какой разрядности NetFramework предназначена программа). Таким образом, одна и та же программа в 32-битной версии Windows будет выполняться поверх 32-битной версии l502api.dll, а в 64-битной - поверх 64-битной версии l502api.dll. Для библиотеки .Net разрядность определяется разрядностью использующего его приложения.

Соответственно, в проекте на LabView, который использует .Net библиотеку,  разрядность используемой библиотеки определяется разрядностью используемой Вами среды.

Установка библиотеки и драйвера для ОС Linux {#sect_setup_linux}
=========================================================================
Для установки драйвера и библиотеки под ОС Linux у Вас есть два варианта:
  - Воспользоваться готовыми собранными пакетами, предоставляемыми "Л Кард". Это рекомендованный способ для дистрибутивов, для которых предоставляются собранные пакеты. Список поддерживаемых дистрибутивов можно посмотреть в документе [\"Использование внешних репозиториев 'Л Кард' для дистрибутивов Linux\"](http://www.lcard.ru/download/lcard_linux_distributions.pdf)
  - Скачать исходники SDK и собрать их самостоятельно (подробнее [в следующем разделе](@ref sect_sdk_src)).

Для примеров работы с модулем L502 на C под Linux Вы можете скачать архив с исходниками SDK и посмотреть на примеры в директории examples/msvc. Несмотря на название, они могут быть собраны GCC под ОС Linux. Для каждого примера есть makefile (с комментариями), а также файл CMakeList.txt для предпочитающих сборку с использованием cmake .


О том, как подключить внешний репозиторий, установить собранные пакеты и о преимуществах данного метода установки описано в документе [\"Использование внешних репозиториев 'Л Кард' для дистрибутивов Linux\"](http://www.lcard.ru/download/lcard_linux_distributions.pdf). Здесь же будет приведен список самих пакетов, использующихся при работе с модулем L502.


Для работы с L502 используются пакеты:
  - <B> libl502api1-dev </B> или <B> libl502api1-devel </B> --- Пакет с файлами l502api для разработчика: заголовочные файлы и линк на библиотеку нужной версии. Нужен при написании своих программ с использованием l502api (зависит от libl502api1)
  - <B> libl502api1 </B>  --- Пакет непосредственно с библиотекой l502api нужной версии. Если вы распространяете свою программу, которая использует l502api, то Вам достаточно включить в зависимости только этот пакет (без пакета с файлами для разработчика)
  - <B> lpcie-dkms </B> --- Пакет с исходниками драйвера (модуля ядра), использующий систему сборки внешних модулей dkms (подробнее описано ниже).
  - <B> lpcie-firm-update </B> --- Утилита для обновления прошивки ПЛИС модуля L502. Пакет включает в себя последнюю версию прошивки ПЛИС и скрипт lpcie-firm-update-all.sh для обновления прошивок всех найденных устройств L502.

  Так как драйвер должен быть собран под конкретную версию ядра (а ядро может обновляться в одной версии дистрибутива или даже могут использоваться разные варианты ядра), то драйвер не может распространятся в уже собранном виде. Его сборка выполняется непосредственно при установке пакета. При этом необходимо предварительно поставить пакет с заголовочными файлами текущего ядра (обычно в пакетах с именами linux-headers или kernel-devel). Для некоторых дистрибутивов может быть несколько вариантов ядра (и соответственно несколько пакетов), более того Вы можете использовать свое ядро. Именно по этой причине пакет не задан зависимостью для lpcie-dkms, в отличие от других зависимостей. Узнать текущую версию ядра можно командой: `uname -r`. Убедиться, что нужные файлы установлены можно проверив наличие файлов в директории /lib/modules/\`uname -r\`/build (обычно это ссылка на заголовки ядра в /usr/src/linux-\<version\> или /usr/src/kernels/\<version\>).

  Если заголовки текущего ядра установлены, то при установке пакета lpcie-dkms будет выполнена сборка драйверов с использованием DKMS (пакет dkms входит в зависимости lpcie-dkms, как и make и gcc, необходимые для сборки). DKMS это достаточно широко распространенная система сборки и управления внешними модулями ядра (она находится в основном репозитории большинства дистрибутивов Linux, хотя ее нет в openSuse, но для нее распространяется  пакет dkms через тот же Open Build System).

  DKMS позволяет:
       - централизованно отслеживать, какие сторонние модули ядра, какие их версии и для каких версий ядра установлены (dkms status)
       - хранит всегда исходники драйвера разных версий в централизованном месте (/usr/src/lpcie-\<version\>)
       - позволяет автоматически пересобирать драйвер при переходе на новое ядро
       - позволяет в любой момент удалить драйвер или любую его версию и все связанные с ним файлы (dkms remove -m lpcie -v \<version\> --all)

  Таким образом, хотя в пакете находятся исходники драйвера, а не собранный драйвер, установка мало чем отличается от установки других пакетов, кроме того, что требует дополнительной установки заголовочных файлов ядра и установка пакета требует значительного времени на сборку.

  При установки нового ядра модуль будет пересобран под него автоматически либо при установке пакета, либо при первом входе в систему с новым ядром.  
  
Исходные коды SDK {#sect_sdk_src}
=========================================================================

Исходные коды всех составных компонентов SDK открыты. Пользователю предоставляется доступ на чтение к репозиторию системы контроля версий [Mercurial](http://mercurial.selenic.com), расположенному по адресу https://bitbucket.org/lcard/lpcie_sdk. Подробнее об использовании открытых репозиториев исходных кодов "Л Кард" на bitbucket.org Вы можете прочитать в документе [\"Использование открытых репозиториев исходных кодов 'Л Кард' на bitbucket.org\"](http://www.lcard.ru/download/lcard_bitbucket_repos.pdf).

Вы также можете скачать архив lpcie_sdk_src.zip со всеми исходными кодами из [прикрепленных файлов проекта репозитория](https://bitbucket.org/lcard/lpcie_sdk/downloads).

Инструкции по сборке находятся в файле исходников INSTALL.txt.



[SDK]: (http://www.lcard.ru/download/lpcie_setup.exe) "\"L-Card PCI Express SDK\""
